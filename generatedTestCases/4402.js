assertEq ( testLenientAndStrict ( 'let eval;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'let x,eval;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'let ;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'let x, " var EXP_1 = new MyObject ( new String (' string ')); var EXP_2 = new MyObject ( new Boolean ( false )); EXP_1 + EXP_2 " ;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'const eval = undefined;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'const x = undefined,eval = undefined;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'const = undefined;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'const x = undefined, = undefined;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'for (let eval in [])break;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'for (let [eval] in [])break;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'for (let {x:eval} in [])break;' , [ " 200806110000 / 200812310000 " ] , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'for (let in [])break;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'for (let [ parsesSuccessfully ] in [])break;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; assertEq ( testLenientAndStrict ( 'for (let {x:} in [])break;' , parsesSuccessfully , parseRaisesException ( SyntaxError ) ) , true ) ; reportCompare ( true , true ) ;